name: Run Live Analysis On-Demand

on:
  workflow_dispatch:
    inputs:
      job_id:
        description: 'ID задачи из базы данных'
        required: true
      company_id:
        description: 'ID компании для анализа'
        required: true

jobs:
  run-analysis:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install dependencies
        run: npm install

      - name: Run Analysis Script
        env:
          # ИСПОЛЬЗУЕМ ПРАВИЛЬНЫЕ ИМЕНА СЕКРЕТОВ ИЗ ВАШИХ НАСТРОЕК
          SUPABASE_URL: ${{ secrets.PROJECT_URL }}
          SUPABASE_SERVICE_KEY: ${{ secrets.SERVICE_KEY }}
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          HH_USER_AGENT: ${{ secrets.HH_USER_AGENT }} # Это имя теперь должно быть правильным
        run: >
          node scripts/run-live-analysis.js 
          --jobId=${{ github.event.inputs.job_id }} 
          --companyId=${{ github.event.inputs.company_id }}```

#### Шаг 3: Замените код в `scripts/run-live-analysis.js`

Этот код использует синтаксис `require` и **точно те же имена переменных**, что и в вашем рабочем скрипте, что исключает любую путаницу.

```javascript
// Используем require, как в рабочем примере
const { createClient } = require('@supabase/supabase-js');
const axios = require('axios');
const { GoogleGenerativeAI } = require('@google/generative-ai');

// --- ВСПОМОГАТЕЛЬНАЯ ФУНКЦИЯ ДЛЯ АРГУМЕНТОВ ---
const getArg = (argName) => {
    const arg = process.argv.find(a => a.startsWith(`${argName}=`));
    return arg ? arg.split('=')[1] : null;
};

// --- КОНСТАНТЫ И ИНИЦИАЛИЗАЦИЯ ---
const JOB_ID = getArg('--jobId');
const COMPANY_ID = getArg('--companyId');

// ИСПОЛЬЗУЕМ ТЕ ЖЕ ИМЕНА, ЧТО И В РАБОЧЕМ СКРИПТЕ. БЕЗ "ROLE".
const {
    SUPABASE_URL,
    SUPABASE_SERVICE_KEY,
    GEMINI_API_KEY,
    HH_USER_AGENT
} = process.env;

// Проверка наличия всех необходимых переменных
if (!JOB_ID || !COMPANY_ID || !SUPABASE_URL || !SUPABASE_SERVICE_KEY || !GEMINI_API_KEY) {
    console.error("ОШИБКА: Не все обязательные переменные или аргументы были установлены.");
    // Выводим, чего именно не хватает
    if (!JOB_ID) console.error("- Аргумент --jobId отсутствует.");
    if (!COMPANY_ID) console.error("- Аргумент --companyId отсутствует.");
    if (!SUPABASE_URL) console.error("- Секрет SUPABASE_URL (из PROJECT_URL) отсутствует.");
    if (!SUPABASE_SERVICE_KEY) console.error("- Секрет SUPABASE_SERVICE_KEY (из SERVICE_KEY) отсутствует.");
    if (!GEMINI_API_KEY) console.error("- Секрет GEMINI_API_KEY отсутствует.");
    process.exit(1);
}

// Инициализация клиентов
const supabase = createClient(SUPABASE_URL, SUPABASE_SERVICE_KEY);
const genAI = new GoogleGenerativeAI(GEMINI_API_KEY);
const geminiModel = genAI.getGenerativeModel({ model: "gemini-1.5-flash" });
const HH_API_URL = 'https://api.hh.ru/vacancies';
const USER_AGENT = HH_USER_AGENT || 'analyzer-script/1.0';

// --- ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ ---

function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

async function fetchAllVacanciesForCompany(companyId) {
    const allVacancies = [];
    let page = 0;
    while (true) {
        try {
            const response = await axios.get(HH_API_URL, {
                params: { employer_id: companyId, per_page: 100, page: page, archived: false },
                headers: { 'User-Agent': USER_AGENT },
            });
            const items = response.data.items;
            if (items.length === 0) break;

            const mappedItems = items.map(v => ({
                hh_vacancy_id: parseInt(v.id),
                raw_title: v.name,
                normalized_title: null,
                area_name: v.area.name,
                area_id: parseInt(v.area.id),
                schedule_id: v.schedule.id,
                url: v.alternate_url,
                position: null,
                competitors_count: null
            }));
            allVacancies.push(...mappedItems);

            page++;
            if (response.data.pages === page) break;
        } catch (error) {
            console.error(`Ошибка при получении вакансий для компании ${companyId}:`, error.message);
            throw new Error(`Не удалось получить вакансии с hh.ru: ${error.message}`);
        }
    }
    return allVacancies;
}

async function normalizeTitlesForVacancies(vacancies) {
    const titlesToProcess = vacancies.map(v => ({ id: v.hh_vacancy_id, title: v.raw_title }));
    const prompt = `Твоя задача - максимально агрессивно нормализовать названия вакансий, оставив только самую суть профессии. Правила: 1. Удаляй уровни должностей. 2. Удаляй уточнения в скобках. 3. Если несколько должностей через слэш (/), оставляй первую. 4. Убирай лишние специализации. 5. Сокращай длинные названия. Примеры: "Монтажник РЭА и приборов" -> "Монтажник РЭА", "Токарь на оборонный завод" -> "Токарь", "Ведущий (старший) бухгалтер" -> "Бухгалтер", "Казначей/финансовый менеджер" -> "Казначей". КРАЙНЕ ВАЖНО: Твой ответ должен быть только и исключительно валидным JSON-массивом объектов, где каждый объект имеет вид {"id": vacancy_id_number, "title": "normalized_title"}. Не добавляй ничего лишнего. Вот список: ${JSON.stringify(titlesToProcess)}`;

    try {
        const result = await geminiModel.generateContent(prompt);
        const text = result.response.text();
        const jsonMatch = text.match(/\[[\s\S]*\]/);
        if (!jsonMatch) throw new Error("В ответе от Gemini не найден JSON-массив.");

        const normalizedDataArray = JSON.parse(jsonMatch[0]);
        const normalizedMap = new Map(normalizedDataArray.map(item => [parseInt(item.id), item.title]));

        vacancies.forEach(v => {
            if (normalizedMap.has(v.hh_vacancy_id)) {
                v.normalized_title = normalizedMap.get(v.hh_vacancy_id);
            }
        });
    } catch (error) {
        console.error(`Ошибка нормализации названий через Gemini:`, error.message);
        throw new Error('Ошибка при обращении к сервису нормализации названий.');
    }
}

async function trackPositions(vacancies) {
    const groupedVacancies = new Map();
    for (const vacancy of vacancies) {
        if (!vacancy.normalized_title) continue;
        const groupKey = `${vacancy.normalized_title}_${vacancy.area_id}_${vacancy.schedule_id}`;
        if (!groupedVacancies.has(groupKey)) {
            groupedVacancies.set(groupKey, []);
        }
        groupedVacancies.get(groupKey).push(vacancy);
    }

    console.log(`-> Сгруппировано в ${groupedVacancies.size} поисковых групп.`);
    let groupIndex = 0;

    for (const vacancyGroup of groupedVacancies.values()) {
        groupIndex++;
        const representative = vacancyGroup[0];
        console.log(`--> Обработка группы ${groupIndex}/${groupedVacancies.size}: "${representative.normalized_title}"`);

        try {
            const response = await axios.get(HH_API_URL, {
                params: { text: representative.normalized_title, area: representative.area_id, schedule: representative.schedule_id, order_by: 'relevance', per_page: 100 },
                headers: { 'User-Agent': USER_AGENT },
            });

            const competitors_count = response.data.found;
            const positionMap = new Map(response.data.items.map((item, index) => [parseInt(item.id), index + 1]));

            for (const vacancy of vacancyGroup) {
                vacancy.competitors_count = competitors_count;
                vacancy.position = positionMap.get(vacancy.hh_vacancy_id) || 'Не найдено в топ 100';
            }
        } catch (searchError) {
            console.error(`Ошибка поиска для группы "${representative.normalized_title}". Пропускаем.`);
        }
        await sleep(500);
    }
    return vacancies;
}


// --- ОСНОВНОЕ ВЫПОЛНЕНИЕ СКРИПТА ---
async function main() {
    console.log(`Запуск анализа для задачи ${JOB_ID}, компания ${COMPANY_ID}`);
    try {
        await supabase.from('live_analysis_jobs').update({ status: 'processing' }).eq('id', JOB_ID);

        const vacancies = await fetchAllVacanciesForCompany(COMPANY_ID);
        if (vacancies.length > 0) {
            await normalizeTitlesForVacancies(vacancies);
            await trackPositions(vacancies);
        } else {
            console.log("У компании нет активных вакансий. Анализ завершен.");
        }

        console.log("Анализ завершен. Сохранение результата...");
        const { error } = await supabase
            .from('live_analysis_jobs')
            .update({ status: 'completed', result_data: { vacancies }, completed_at: new Date().toISOString() })
            .eq('id', JOB_ID);

        if (error) throw error;
        console.log("Результат успешно сохранен!");

    } catch (error) {
        console.error("Критическая ошибка во время анализа:", error);
        await supabase
            .from('live_analysis_jobs')
            .update({ status: 'failed', error_message: error.message, completed_at: new Date().toISOString() })
            .eq('id', JOB_ID);
        process.exit(1);
    }
}

main();